Идея кода строится вокруг интерфейсов `Node` и `FlatNode` (временный алиас интерфейса `Node`)

Интефейс `Node` создан для удобства представления файлов репозитория DbGit, Yaml файа описания InfoUniverse и других многоуровневые маппингов
Также `Node` пригоден для прямого принтинга в Yaml 

Структура описания объектов БД в файловом репозитории DbGit отличается от иерархической в [документе InfoUniverse](https://gitlab.fusionsoft.ru/fusionsoft-ru/iu/info-universe/-/blob/master/iuData/Sample-DBD/sample-dbd.yaml) и от плоской, которая удобна для формирования других документов вроде SQL восстановления схемы 

`FlatNode` - нода в плоской структуре объектов БД. Ее формат я представляю как маппинг со следующими полями
1. Общая часть
  * тип объекта
  * тип БД
  * версия БД
  * название
  * владелец
2. Часть, специфичная для конкретного типа любой БД
  * имя в бд
  * ? схема
  * ... прочие параметры, специфичные для типа
3. Часть, специфичная для конкретного типа и конкретной БД
  * ? дефиниция ключа партиционирования
  * ? ...

Соответсвенно я предлагаю собирать данные о существующих объектах СУБД сразу в формате `FlatNode`, что уже есть в реализациях в DbGit.DBAdapter

Чтобы составить `FlatNode` из какого-то маппинга, сначала удобно распарсить маппинг в какую-то типизованную структуру на Java, см. интерфейcы `nodes.iu.IuDatabaseDescription` | `nodes.flat.FromIUDatabaseDescription`

Сопутствующие классы `FromDbGitRepo`, `FromAnyConnection`, `FromPgConnection`, `FromIUDatabaseDescription` - составные части конвертеров, см. класс `nodes.flat.FlatNodesOf`

Интерфейс `DbObject` - конечное представление FlatNode, коллекция экземпляров которого - все, что нужно для алгоритма рестора схемы в СУБД.
Для его реализации возможно написать классы-парсеры типа `FlatNodePgTable`, но пока представлены только парсеры `dbobjects.FromIUDatabaseDescription` | `dbobjects.FromFlatNodes`

В качестве приоритетного направления развития проекта вижу разработку конвертеров `IuDatabaseDescription` <-> `FlatNode` <-> `RepoFileNodes`, что позволит в кратчайшие сроки начать использовать описание InfoUniverse с текущей версией DatabaseGit: подключить этот код как библиотеку и использовать в виде `IuDatabaseDescription` -> `RepoFileNodes`

_/offtop_
Что касается данных таблиц, то я убежден в том, что их полный drop и последующим bulk insert при каждом изменении таблицы быстрее цепочки single drop / single update и такой алгоритм сделает сам процесс рестора схемы проще и прозрачнее. 

Вообще есть большое и трудно определимое множество ситуаций, когда частичный alter/update какого-либо объекта в контексте схемы невозможен (как в случае с UDT) и почти всегда drop/create работает просто быстрее с учетом сетевых задержек. 



