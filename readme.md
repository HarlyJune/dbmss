Идея кода состоит в том, чтобы представить в коде артефакты приложения DbGit после рефакторинга.

Основной функционал DbGit, из которого происходит большинство контрактов и use-case'ов на уровне пользователя - **`миграция`**, приведение `Persistent IS` к `Target IS`.

То, с чем мы можем работать в контексте IS - описания этого самого IS. Методика - получение текущего описания БД (Persistent DBD) и воздействие над Persistent IS с целью приведения его состояния к целевому описанию (Target DBD). 

Для взаимодействия с `IS (состояния инстанса)` (получение и изменение свойств и данных) на самом низком уровне мы можем использовать `SQL` в связке с `java.sql.connection` и внешние утилиты, например `pg_dump` или `Pyrseas`.

Формат данных DBD, представляет собой дерево иерархически выстроенных описаний, их множество - `[*Description]`. Оно включает в себя как верхушку дерева`DBD (Database Description)`, так и самый нижние уровни дерева по типу `Column Description`. 
Это не самая удобная структура именно для работы с ней в коде, однако она хорошая для представления описания стуруктуры БД пользователем или в git.

По DBD у меня имеются вопросы в плане типизации по СУБД, т.к. формат еще не утвержден, и я не знаю, как оно будет реализовано: 

- номенклартура объектов СУБД: некоторые объекты уникальны для СУБД (пример - `domain` в postgres)
- иерархия DBD: в некоторых СУБД есть tablespace, в некоторых namespace, они на уровень выше схемы
- поля отдельных объектов СУБД: где-то их больше (пример - `db role` в mssql)




Интерфейс `MappingDiff` служит для создания диффа на основе YamlMapping'ов, для представления в человекочитаемом виде. Его не имеет смысла использовать для чего-то еще, а контракт и реализация достаточно тривиальны и я предлагаю вернуться к нему позже.

Для миграции IS по SQL нам недостаточно просто сгенерировать ряд `Create SQL`, `Drop SQL` и `Update SQL` (в сумме это множество `DDL`) по каждому различающемуся Description. Есть ряд случаев, когда на результирующий SQL влияет различие Description на разных уровнях, и тогда между парой DBD появляются `суб-миграции`. В самом простом случае примером стратегии миграций может послужить `(1) дроп всех ограничений таблиц перед внесением изменений над ними и пересоздание ограничений после`, а в сложном - `каст всей колонки таблицы, если ее тип изменился и старый можно перевести в новый таким образом`, `(3) пересоздание таблицы, когда изменился порядок колонок, тип данных (когда для его изменения не получится использовать каст) или определение первичного ключа партиционирования в postgres DBMS версии ниже 11`

 То есть, размерность `[MappingDiffNode]` != размерности `[DDL]`
 
 Давайте теперь разберем определение суб-миграции. 
 
 - *Дроп всех ограничений таблиц перед внесением изменений*  потребует список изменяемых таблиц. 
 - *пересоздание таблицы, когда ...* потребует информацию о соблюдении ряда `условий` по различию пары <Table Description>
 - *не получится использовать каст* - вычисляемое `свойство`, которого нет в Description. 
 
 Суб-миграция применяется, когда соблюдается ряд условий. Для первой достаточно, чтобы менялась хоть одна таблица. А вот для третьей кроме условий из ее определения нужно, чтобы не применялась статегия (2).
 
 То есть применение одной суб-миграции может делать бессмысленной другую. 
 
 Из этого у нас формируется иерархия множества `[условий]`, где условие может состоять как из данных из DBD, так и из вычисляемых свойств и других условий. Использования условий другими условиями и определяет иерархию [условий]. 

 Иерархия же стратегий не соответствует в общем случае иерархии условий, но определяется также использованием миграцией других миграцией типа `миграция IS` -> (`миграция таблицы` -> (`каст колонки`, `добавление колонки`, `добавление констрейнта`, `изменение PKD`, `дроп таблицы`), ... )

 Получается следующий список артефактов в рамках миграций
 
 - миграция IS
 - миграция Yaml DBD
 - суб-миграция объекта БД конкретного типа
 - набор известных суб-миграций объектов БД конкретного типа (и СУБД)
 - условие diff'а двух объектов БД определенного типа (и СУБД)
 - условие применимости суб-миграции 
 
 Можно ли иметь общий код в рамках миграций? Или будет дублирование?
 
 Миграцию с такой оговоркой можно описать как: common-mgr + vendor-spec-mg
 Причем vendor-specific может встречаться на каком угодно `этапе` миграции - не уровне, т.к. уровни у нас только в DBD.
 Этапы зависят от взаимозависимости объектов. Эти зависимости формируются не только иерархически. 
 
 Как было бы удобно представить список всех объектов БД? В виде Collection, наверное, где у каждого описания объекта `DBODescription` есть
 
 - свойства, по которым его можно отфильтровать/отсортировать
 - свойства, по которым его можно восстановить 
 
 Что касается dbms-specific, нужно, чтобы эти объекты/параметры можно было достать из DBD. 
 
 Пусть DBDToServerMigration имеет внутри себя такие суб-миграции:
 
 - PreRestoreMigration : Migration(DiffPair<Collection<DBODescription>>) - объединит в себе действия, которые мы делаем над множеством объектов в любой СУБД до рестора
 - RestoreMigration : ...
 - AfterRestoreMigration : ...
 
 Пусть пайплайн описаний будет такой:
 
 1. DBD со своей иерархией
 2. Коллекция/DBO в плоском виде с названиями, типами, id и своей нетипизованной коллекцией property
 3. Описание объекта в конкретной СУБД со строго типизованным набором property
 
Мало того, мы хотим добавить в наш console application интерактив на разрешение спорных ситуаций. Например, когда выбранная стратегия затрагивает много данных, будет задан вопрос `мы пересоздаем 4 таблицы с данными общей размерностью в более 10 млн. ячеек, вы уверены, что мы это будем делать сейчас?`. 

Получается, у миграций есть **`restore params`**, вопросы это будут или не вопросы, дело другое, но тому актору, который будет представлять миграции, параметры нужно будет передавать. 

В общем случае, у нас уже были параметры в dbgit, которые шли из процессора агрументов командной строки. Чтобы не лишать DbGit возможности работать в пакетном режиме, нужно будет предусмотреть установку параметры миграций через аргументы командной строки, которые будут исключать работу в интерактивном режиме. 

Задачей является реализация **миграций**. На низком уровне в этом деле мы приходим к генерации SQL и выполнению его над java.sql.Connection, но это не всегда.

Мы именно **выполняем** миграцию, а не генерируем SQL в общем случае. Мы так же не восстанавливаем объекты или всю структуру БД в общем случае. 

Миграции, которая в виде SQL кода, написанного человеком, нам уже нужно не описание, а Persistent IS в том состоянии, в котором он был на момент написания кода. 
Для такой миграции Persistent IS нужно привести к тому виду и только потом выполнить код.

Давайте выделим два вида миграций - `Автоматическая миграция (AM)` и `Пользовательская миграция (UM)`.
AM = знание о текущем IS + знание о целевом IS + набор известных нам подходов для приведения P(IS) к T(IS).
UM = знание о начальном IS (SIS) + набор подходов приведения PIS к SIS или хотя бы проверки, что PIS == SIS + последовательность SQL кода. 

